---
title: C++ 개념정리
last_modified_at: 2022-01-16
categories: 
  - Programming
tags:
  - C++
---

# 컴파일 과정
- Compile : 소스코드 --> 어셈블리어로 변환, CPU에 의존적임
- Assemble : 어셈블리어 --> 목적파일(이진파일)로 생성, 주소정보가 기록되지 않음
- Linking : 목적파일,라이브러리 --> 실행파일로 변환, 주소정보가 기록되어 있음. OS에 의존적임

# 프로그램의 메모리 공간
- 데이터 : 전역변수가 저장
- 스택 : 지역변수 및 매개변수 저장
- 힙 : 동적 메모리 저장(malloc)
- malloc & free : malloc으로 할당된 메모리는 free하지 않으면 해제되지 않는다.

# 함수 오버로딩
- 함수 이름은 같으나, 전달 인자를 다르게 정의된 함수.
- C++은 함수 이름과 인자를 동시에 참조하여, 호출할 함수를 결정함

# Namespace
- 이름공간으로 함수,클래스,변수 명을 구분 가능

# 인라인 함수
- 컴파일러에게 전처리 해달라고 요청하는 키워드
- inline키워드가 없어도 인라인화 될 수 있음, 있어도 안될 수 도 있음.
- 매크로 함수는 복잡한 함수 정의가 어렵지만, 인라인 함수는 정의하기 쉬움 
- 매크로 함수는 자료형에 독립적이지만, 인라인 함수는 자료형을 정해야 함. template 문법으로 해결 가능

# 참조형 변수
- 동일한 주소를 가르키고 있는 변수, 별칭.
- const 참조자 : const 참조자 변수를 이용한 값 변경을 허용하지 않겠다는 의미
- 참조자로 힙영역의 접근 가능함

# 포인터
- 변수의 주소(=상대주소) 값을 저장
- 주소연산자(=&)을 통해 변수가 가지고 있는 주소 값을 가져올 수 있음
- 역참조연산자(=*)로 주소가 가르키고 있는 값을 가져올 수 있음

# new, delete, malloc, free
- new 연산자로 할당한 메모리는 free로만 해제해야 함
- new와 malloc의 차이는 new는 연산자이고, malloc은 함수이다
- new 키워드 사용시, malloc함수가 호출되어 동적 메모리가 할당됨

# 클래스
- C++의 struct는 C언어의 struct와 다름. C++의 struct는 class처럼 사용
- 접근 제어 지시자는 public(어디든 접근 허용), protected(자식 클래스만 접근허용), private(클래스 내에서만 접근허용)

# C++ 파일 분할
- 선언은 Header파일(*.h), 정의는 Cpp파일에 정의
- 인라인 함수는 헤더파일과 함께 정의함

# 객체지향 프로그래밍
- 사물,대상, 행위를 실체화하는 형태의 프로그래밍

# 정보은닉
- 클래스 멤버 변수 접근을 외부로부터 막는 것
- 멤버변수 접근을 클래스 내부에서만 접근 가능하도록 private로 선언
- 멤버 함수에 const를 선언하여 변수 값 조작을 막을 수 도 있음
- 외부에서 접근 수행할 경우, getter, setter 메소드로 제공

# 캡슐화
- 관련 있는 모든 것을 클래스로 묶는 것

# 생성자와 소멸자
- 생성자는 객체 생성 시, 딱 한번만 호출됨
- 생성자 호출 시, private 변수 초기화할 때 이니셜라이저로 초기화 가능
- 이니셜라이저 이용 시, 변수 선언과 동시에 초기화 된다고 생각하면 됨
- 소멸자는 객체 소멸 시, 딱 한번만 호출됨
- 멤버변수에 동적 메모리 할당한 변수가 있을 경우, 소멸자에서 메모리 해제 필요

# this 포인터
- 객체 그 자신의 주소값을 가르킴. 자기 참조.

# 복사 생성자
- 기존 객체로 새로운 객체를 생성하는 함수
- 복사생성자 호출시점 ( 객체 초기화/함수 인자로 전달/함수에서 객체 반환)
- 소괄호()를 이용하여 객체를 초기화 할 때, 복사 가능 ex) AAA a1(a2);
- 얕은 복사 : 멤버 대 멤버의 값만 복사, 메모리 참조값이 같을 수 있음
- 깊은 복사 : 동적 메모리를 새로 할당하고, 값을 복사함.
- 디폴트 복사 생성자 : 사용자 정의 복사 생성자가 없을 때, 자동으로 삽입 됨. 얕은 복사 수행

# explicit
- 묵시적 형변환을 금지하는 키워드

# friend, static, const
- const키워는 함수 오버로딩의 조건이 됨
- friend로 지정된 class 또는 전역함수에게 private 멤버 접근 허용가능 (정보 은닉을 파괴)
- static 키워드로 선언된 멤버변수, 멤버함수는 프로그램 실행과 동시에 생성됨. 해당 클래스에 선언된 static은 공유함
- Mutable로 선언된 변수는 const 함수에서 수정가능

# 상속
- 기존 클래스를 재활용을 목적으로 사용되는 문법
- 클래스를 상속구조로 변경하여 변경사항을 최소화 하기도 함
- public 상속 : 접근제어 권한 그대로 상속
- protected 상속 : protected보다 넓은 접근 범위는 protected로 상속
- private 상속 : private보다 넓은 접근 범위는 private로 상속
- 클래스 간 IS-A, HAS-A 관계가 성립하면 상속으로 표현이 매우 적절함

# 객체 포인터의 참조관계
- 객체 포인터는 상속을 받은 부모 클래스를 가르킬 수 있음
- 부모 클래스에서 자식 클래스의 멤버를 참조할 수 없음 (컴파일러는 포인터의 자료형 기준으로 판단하기 때문)

# 가상함수
- 컴파일러는 포인터 자료형을 기준으로 호출할 함수를 판단함
- virtual로 선언된 함수는 포인터 형의 상관없이 객체의 마지막 오버라이딩 함수를 호출함

# 순수 가상함수
- 몸체가 정의되지 않는 가상함수를 순수 가상함수라고 함
- 하나 이상의 순수 가상함수를 멤버로 두면, 추상 클래스가 됨

# 다형성
- 함수 오버로딩, 오버라이딩, 템플릿 함수, 가상함수 등 이름은 같으나 다른 동작을 하는 경우를 말함

# 가상 소멸자
- 상속관계가 있는 클래스인 경우, 소멸자는 해당 클래스형의 소멸자만 호출함. (부모 클래스 생성 시, 동적 메모리를 할당한 경우 메모리 누수가 발생함)
- 소멸자에 virtual 키워드를 붙여, 소멸자 호출 시, 부모 클래스의 소멸자도 호출되도록 설정함

# 멤버함수와 가상함수의 동작원리
- 멤버 함수는 함수를 가르키는 포인터 변수이므로, 실제 멤버함수의 정의 내용은 모두 공유함
- 클래스 내에 가상함수가 포함되면, V-table(Key-Value 테이블, 함수명-주소)이 생성되고 이를 참조함
- 가상 함수 호출 시, v-table을 참조하여 함수를 실행함

# 다중상속
- 두 개 이상의 부모 클래스를 상속 (득보다 실이 많은 문법이라고 함..)
- 다중 상속 받은 두개 이상의 클래스가 같은 부모를 상속받을 경우, 불필요한 함수 호출과 모호성이 발생함

# 가상 상속
- 다중 상속으로 인해, 불필요한 부모클래스의 멤버함수가 두번 호출되는 것을 막음
- 가상함수 선언으로 인해, v-table이 추가적으로 생성되어 메모리가 커짐.
- offset 기반으로 vtable ptr에서 참조할 주소를 찾아야 하므로, 이에 대한 오버헤드도 발생.

# 연산자 오버로딩
- 

# 템플릿(Template)
- 

# 예외처리
- 

참고자료
윤성우의 열혈 C++ - http://www.orentec.co.kr/teachlist/CPP_BASIC_1/teach_sub1.php
